<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GBA ROM Forge - Deep Analysis</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00ff88;
            --secondary: #00ccff;
            --accent: #ff0088;
            --bg-dark: #0a0e17;
            --bg-card: #141927;
            --bg-elevated: #1a2332;
            --text-primary: #ffffff;
            --text-secondary: #8892b0;
            --border: #2a3649;
            --success: #00ff88;
            --warning: #ffaa00;
            --error: #ff0055;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 136, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 204, 255, 0.05) 0%, transparent 50%);
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 60px 20px 40px;
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 4em;
            font-weight: 900;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 50%, var(--accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .badge {
            display: inline-block;
            padding: 8px 20px;
            background: linear-gradient(135deg, var(--accent), var(--primary));
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.9em;
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 30px;
            margin: 20px 0;
            transition: all 0.3s ease;
        }

        .card:hover {
            border-color: var(--primary);
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.1);
        }

        .card-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--primary);
        }

        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-zone:hover {
            border-color: var(--primary);
            background: rgba(0, 255, 136, 0.02);
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: var(--bg-dark);
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .info-item {
            background: var(--bg-elevated);
            padding: 15px;
            border-radius: 8px;
        }

        .info-label {
            font-size: 0.85em;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .info-value {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--primary);
            margin-top: 5px;
        }

        .offset-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .offset-table th {
            background: var(--bg-elevated);
            color: var(--primary);
            padding: 12px;
            text-align: left;
            border-bottom: 2px solid var(--primary);
        }

        .offset-table td {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            vertical-align: top;
        }

        .offset-table tr:hover {
            background: var(--bg-elevated);
        }

        .category-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .cat-pointer { background: rgba(0, 255, 136, 0.2); color: var(--primary); }
        .cat-text { background: rgba(136, 136, 255, 0.2); color: #8888ff; }
        .cat-table { background: rgba(255, 170, 0, 0.2); color: var(--warning); }
        .cat-code { background: rgba(255, 0, 136, 0.2); color: var(--accent); }
        .cat-graphics { background: rgba(0, 204, 255, 0.2); color: var(--secondary); }
        .cat-palette { background: rgba(255, 100, 200, 0.2); color: #ff64c8; }

        .alert {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid;
        }

        .alert-success { background: rgba(0, 255, 136, 0.1); border-color: var(--success); color: var(--success); }
        .alert-error { background: rgba(255, 0, 85, 0.1); border-color: var(--error); color: var(--error); }
        .alert-info { background: rgba(0, 204, 255, 0.1); border-color: var(--secondary); color: var(--secondary); }

        .hidden { display: none; }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }

        #scanStatus {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-card);
            padding: 40px;
            border-radius: 12px;
            border: 2px solid var(--primary);
            text-align: center;
            z-index: 1000;
        }

        .spinner {
            border: 3px solid var(--border);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .sprite-preview {
            display: inline-block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 1px solid var(--border);
            background: repeating-conic-gradient(#1a1a1a 0% 25%, #2a2a2a 0% 50%) 50% / 8px 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .sprite-preview:hover {
            transform: scale(3);
            z-index: 10;
        }

        .decoded-info {
            background: var(--bg-dark);
            padding: 10px;
            border-radius: 4px;
            margin-top: 5px;
            font-size: 0.85em;
        }

        .hex-decode {
            color: var(--secondary);
            font-weight: 600;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }

        .modal-content {
            background-color: var(--bg-card);
            margin: 5% auto;
            padding: 30px;
            border: 2px solid var(--primary);
            border-radius: 12px;
            width: 80%;
            max-width: 800px;
        }

        .close {
            color: var(--text-secondary);
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: var(--primary);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="logo">GBA ROM FORGE</h1>
            <p class="subtitle">Deep ROM Analysis & Asset Extraction</p>
            <span class="badge">üî¨ ADVANCED PATTERN DETECTION + ASSET VIEWER</span>
        </div>

        <div class="card">
            <h2 class="card-title">üìÅ Load GBA ROM</h2>
            <div class="upload-zone" id="uploadZone">
                <div style="font-size: 3em;">üéÆ</div>
                <h3>Drop GBA ROM here or click to browse</h3>
                <p style="color: var(--text-secondary); margin-top: 10px;">Supports .gba files only</p>
                <input type="file" id="romInput" accept=".gba">
            </div>
        </div>

        <div id="romInfo" class="hidden">
            <div class="card">
                <h2 class="card-title">üìä ROM Information</h2>
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">File Name</div>
                        <div class="info-value" id="fileName">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Size</div>
                        <div class="info-value" id="fileSize">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Game Title</div>
                        <div class="info-value" id="gameTitle">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Game Code</div>
                        <div class="info-value" id="gameCode">-</div>
                    </div>
                </div>

                <div class="alert alert-info">
                    <strong>üî¨ Deep Analysis Features:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li>‚úÖ Detects GBA pointers with hex‚Üídecimal conversion</li>
                        <li>‚úÖ Finds and decodes ASCII/Unicode text strings</li>
                        <li>‚úÖ Identifies data tables (items, stats, moves)</li>
                        <li>‚úÖ Extracts sprites and graphics (4bpp/8bpp)</li>
                        <li>‚úÖ Detects color palettes (GBA 15-bit format)</li>
                        <li>‚úÖ Analyzes pointer relationships</li>
                    </ul>
                </div>

                <button class="btn" id="scanBtn" style="width: 100%; margin-top: 20px;">üîç Start Deep Analysis</button>
            </div>
        </div>

        <div id="resultsSection" class="hidden">
            <div class="card">
                <h2 class="card-title">üéØ Detected Patterns & Assets</h2>
                
                <div class="info-grid" style="margin-bottom: 20px;">
                    <div class="info-item">
                        <div class="info-label">Pointers</div>
                        <div class="info-value" id="pointerCount">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Text Strings</div>
                        <div class="info-value" id="textCount">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Data Tables</div>
                        <div class="info-value" id="tableCount">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Graphics</div>
                        <div class="info-value" id="graphicsCount">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Palettes</div>
                        <div class="info-value" id="paletteCount">0</div>
                    </div>
                </div>

                <input type="text" id="searchBox" placeholder="Search patterns..." 
                       style="width: 100%; padding: 10px; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); margin-bottom: 15px;">

                <div style="overflow-x: auto;">
                    <table class="offset-table">
                        <thead>
                            <tr>
                                <th>Offset</th>
                                <th>Type</th>
                                <th>Description</th>
                                <th>Decoded Data</th>
                                <th>Preview</th>
                            </tr>
                        </thead>
                        <tbody id="resultsTable">
                        </tbody>
                    </table>
                </div>

                <div class="pagination" id="pagination">
                    <button class="btn btn-secondary" id="prevBtn">‚Üê Previous</button>
                    <span id="pageInfo" style="color: var(--text-secondary);">Page 1 of 1</span>
                    <button class="btn btn-secondary" id="nextBtn">Next ‚Üí</button>
                </div>

                <div id="loadMoreSection" class="hidden" style="text-align: center; margin: 20px 0;">
                    <div class="alert alert-info">
                        <p><strong>Scan paused at <span id="currentCount">0</span> patterns</strong></p>
                        <p>ROM scanned: <span id="scanPercent">0</span>%</p>
                    </div>
                    <button class="btn" id="loadMoreBtn">üîç Scan 150 More Patterns</button>
                </div>

                <button class="btn btn-secondary" id="exportBtn" style="width: 100%; margin-top: 20px;">üì§ Export Pattern Map (JSON)</button>
            </div>
        </div>

        <div id="scanStatus" class="hidden">
            <div class="spinner"></div>
            <h3 id="scanMessage">Scanning ROM...</h3>
            <p id="scanProgress" style="color: var(--text-secondary); margin-top: 10px;">Please wait...</p>
        </div>

        <div id="alerts"></div>
    </div>

    <!-- Modal for viewing sprites -->
    <div id="spriteModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2 style="color: var(--primary); margin-bottom: 20px;">Graphics Asset Viewer</h2>
            <div id="modalContent"></div>
        </div>
    </div>

    <script>
        let romData = null;
        let romFileName = '';
        let allPatterns = [];
        let filteredPatterns = [];
        let currentPage = 1;
        let scanPosition = 0;
        let scanComplete = false;
        const patternsPerPage = 100;
        const initialScanLimit = 500;
        const loadMoreLimit = 150;

        // File upload
        const uploadZone = document.getElementById('uploadZone');
        const romInput = document.getElementById('romInput');

        uploadZone.onclick = () => romInput.click();
        uploadZone.ondragover = (e) => { e.preventDefault(); uploadZone.style.borderColor = 'var(--secondary)'; };
        uploadZone.ondragleave = () => { uploadZone.style.borderColor = 'var(--border)'; };
        uploadZone.ondrop = (e) => {
            e.preventDefault();
            uploadZone.style.borderColor = 'var(--border)';
            if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
        };
        romInput.onchange = (e) => { if (e.target.files.length) handleFile(e.target.files[0]); };

        async function handleFile(file) {
            if (!file.name.toLowerCase().endsWith('.gba')) {
                showAlert('error', '‚ùå Please select a .gba file');
                return;
            }

            romFileName = file.name;
            romData = new Uint8Array(await file.arrayBuffer());

            // Parse GBA header
            const title = String.fromCharCode(...romData.slice(0xA0, 0xAC)).replace(/\0/g, '').trim();
            const code = String.fromCharCode(...romData.slice(0xAC, 0xB0));

            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatBytes(file.size);
            document.getElementById('gameTitle').textContent = title || 'Unknown';
            document.getElementById('gameCode').textContent = code || 'Unknown';

            document.getElementById('romInfo').classList.remove('hidden');
            showAlert('success', `‚úÖ Loaded: ${title || file.name}`);
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        // Scan button
        document.getElementById('scanBtn').onclick = async () => {
            if (!romData) return;

            allPatterns = [];
            scanPosition = 0;
            scanComplete = false;

            showScanStatus('Deep analyzing ROM structure...');
            await sleep(500);

            await scanPatterns(initialScanLimit);

            hideScanStatus();
            document.getElementById('resultsSection').classList.remove('hidden');
            updateDisplay();

            showAlert('success', `‚úÖ Found ${allPatterns.length} patterns & assets`);
        };

        async function scanPatterns(limit) {
            const startCount = allPatterns.length;

            for (let i = scanPosition; i < romData.length - 32; i++) {
                if (allPatterns.length - startCount >= limit) {
                    scanPosition = i;
                    scanComplete = false;
                    updateLoadMore();
                    break;
                }

                // 1. DETECT GBA POINTERS with decoding
                if (i % 4 === 0) {
                    const ptr = readU32(i);
                    if (ptr >= 0x08000000 && ptr <= 0x09FFFFFF) {
                        const offset = ptr - 0x08000000;
                        if (offset < romData.length) {
                            // Try to determine what the pointer points to
                            const targetData = romData.slice(offset, offset + 16);
                            let pointsTo = 'Unknown Data';
                            
                            // Check if it's text
                            if (isASCII(targetData[0]) && isASCII(targetData[1])) {
                                pointsTo = 'Possible Text';
                            }
                            // Check if it's another pointer table
                            else if ((readU32Arr(targetData, 0) & 0xFF000000) === 0x08000000) {
                                pointsTo = 'Pointer Table';
                            }

                            allPatterns.push({
                                offset: '0x' + i.toString(16).toUpperCase(),
                                type: 'pointer',
                                desc: `Pointer ‚Üí ${pointsTo}`,
                                decoded: `ROM: 0x${offset.toString(16).toUpperCase()} (${offset} dec)`,
                                preview: `0x${ptr.toString(16).toUpperCase()}`,
                                value: ptr,
                                targetOffset: offset
                            });
                        }
                    }
                }

                // 2. DETECT ASCII/UNICODE TEXT with decoding
                if (romData[i] >= 0x20 && romData[i] <= 0x7E) {
                    let text = '';
                    let j = i;
                    while (j < romData.length && romData[j] >= 0x20 && romData[j] <= 0x7E && j - i < 100) {
                        text += String.fromCharCode(romData[j++]);
                    }
                    if (text.length >= 4 && text.length <= 100) {
                        // Try to categorize the text
                        let category = 'Generic Text';
                        const lower = text.toLowerCase();
                        
                        if (/^[A-Z]{2,}$/. test(text.slice(0, Math.min(20, text.length)))) {
                            category = 'Possible Item/Move Name';
                        } else if (text.includes('HP') || text.includes('ATK') || text.includes('DEF')) {
                            category = 'Stat-related Text';
                        } else if (text.match(/\d+/)) {
                            category = 'Text with Numbers';
                        }

                        allPatterns.push({
                            offset: '0x' + i.toString(16).toUpperCase(),
                            type: 'text',
                            desc: category,
                            decoded: `Length: ${text.length} chars | ASCII`,
                            preview: `"${text.substring(0, 40)}${text.length > 40 ? '...' : ''}"`,
                            fullText: text
                        });
                        i += text.length - 1;
                    }
                }

                // 3. DETECT DATA TABLES with decoding
                if (i % 16 === 0 && i < romData.length - 128) {
                    for (let size of [12, 16, 20, 24, 28, 32, 40, 44]) {
                        let matches = 0;
                        const entries = [];
                        
                        for (let rep = 0; rep < 10; rep++) {
                            const entryOffset = i + (rep * size);
                            if (entryOffset + size > romData.length) break;
                            
                            const entry = romData.slice(entryOffset, entryOffset + size);
                            entries.push(entry);
                            
                            // Check for structured data
                            if (entry.some(b => b !== 0 && b !== 0xFF)) {
                                matches++;
                            }
                        }
                        
                        if (matches >= 5) {
                            // Try to decode the table structure
                            const firstEntry = entries[0];
                            let decoded = [];
                            
                            // Common Pokemon data patterns
                            if (size === 28) {
                                decoded.push(`Possible Pokemon Base Stats`);
                                decoded.push(`HP: ${firstEntry[0]}, ATK: ${firstEntry[1]}, DEF: ${firstEntry[2]}`);
                            } else if (size === 12) {
                                decoded.push(`Possible Item/Move Data`);
                            } else if (size === 44 || size === 40) {
                                decoded.push(`Possible Pokemon Entry (${size}B)`);
                            } else {
                                decoded.push(`${size}-byte entries, ${matches} found`);
                            }

                            const bytes = Array.from(firstEntry.slice(0, 8))
                                .map(b => b.toString(16).toUpperCase().padStart(2, '0')).join(' ');

                            allPatterns.push({
                                offset: '0x' + i.toString(16).toUpperCase(),
                                type: 'table',
                                desc: `Data Table (${size}B √ó ${matches}+ entries)`,
                                decoded: decoded.join(' | '),
                                preview: bytes + '...',
                                entrySize: size,
                                entryCount: matches
                            });
                            i += size * matches - 1;
                            break;
                        }
                    }
                }

                // 4. DETECT COLOR PALETTES (GBA 15-bit RGB)
                if (i % 32 === 0 && i < romData.length - 32) {
                    // GBA palettes are 16 colors √ó 2 bytes = 32 bytes
                    let validColors = 0;
                    const colors = [];
                    
                    for (let c = 0; c < 16; c++) {
                        const color = readU16(i + c * 2);
                        // GBA uses 15-bit color (5 bits per channel)
                        if (color <= 0x7FFF) {
                            validColors++;
                            const r = (color & 0x1F) << 3;
                            const g = ((color >> 5) & 0x1F) << 3;
                            const b = ((color >> 10) & 0x1F) << 3;
                            colors.push({ r, g, b });
                        }
                    }

                    if (validColors >= 12) {
                        allPatterns.push({
                            offset: '0x' + i.toString(16).toUpperCase(),
                            type: 'palette',
                            desc: `Color Palette (${validColors} colors)`,
                            decoded: `GBA 15-bit RGB palette`,
                            preview: 'Click to view',
                            colors: colors,
                            isPalette: true
                        });
                        i += 31;
                    }
                }

                // 5. DETECT COMPRESSED GRAPHICS (LZ77)
                if (romData[i] === 0x10 && i < romData.length - 8) {
                    const compSize = readU24(i + 1);
                    if (compSize > 0 && compSize < 0x10000 && i + compSize + 4 < romData.length) {
                        allPatterns.push({
                            offset: '0x' + i.toString(16).toUpperCase(),
                            type: 'graphics',
                            desc: 'LZ77 Compressed Graphics',
                            decoded: `Compressed size: ${compSize} bytes`,
                            preview: 'Click to decompress & view',
                            isCompressed: true,
                            compSize: compSize
                        });
                        i += compSize + 3;
                    }
                }

                // 6. DETECT UNCOMPRESSED 4BPP GRAPHICS
                if (i % 32 === 0 && i < romData.length - 512) {
                    // Look for tile patterns (8x8 pixels, 4bpp = 32 bytes per tile)
                    const tileData = romData.slice(i, i + 512); // 16 tiles
                    
                    // Check if data looks like graphics (varied but not random)
                    let uniqueValues = new Set(tileData).size;
                    let zeroCount = tileData.filter(b => b === 0).length;
                    
                    if (uniqueValues > 4 && uniqueValues < 200 && zeroCount < 400 && zeroCount > 50) {
                        allPatterns.push({
                            offset: '0x' + i.toString(16).toUpperCase(),
                            type: 'graphics',
                            desc: 'Possible 4BPP Sprite Data',
                            decoded: `~${Math.floor((romData.length - i) / 32)} tiles available`,
                            preview: 'Click to render',
                            isGraphics: true,
                            bpp: 4
                        });
                        i += 511;
                    }
                }

                // Mark complete
                if (i >= romData.length - 33) {
                    scanComplete = true;
                    scanPosition = romData.length;
                    document.getElementById('loadMoreSection').classList.add('hidden');
                }
            }

            updateStats();
            populateTable();
        }

        function updateStats() {
            document.getElementById('pointerCount').textContent = allPatterns.filter(p => p.type === 'pointer').length;
            document.getElementById('textCount').textContent = allPatterns.filter(p => p.type === 'text').length;
            document.getElementById('tableCount').textContent = allPatterns.filter(p => p.type === 'table').length;
            document.getElementById('graphicsCount').textContent = allPatterns.filter(p => p.type === 'graphics').length;
            document.getElementById('paletteCount').textContent = allPatterns.filter(p => p.type === 'palette').length;
        }

        function populateTable() {
            filteredPatterns = [...allPatterns];
            currentPage = 1;
            renderPage();
        }

        function renderPage() {
            const start = (currentPage - 1) * patternsPerPage;
            const end = Math.min(start + patternsPerPage, filteredPatterns.length);
            const pageData = filteredPatterns.slice(start, end);

            const tbody = document.getElementById('resultsTable');
            tbody.innerHTML = pageData.map((p, idx) => {
                let previewHTML = `<code style="color: var(--primary);">${p.preview}</code>`;
                
                // Add palette color swatches
                if (p.isPalette && p.colors) {
                    previewHTML = p.colors.map(c => 
                        `<div style="display: inline-block; width: 16px; height: 16px; background: rgb(${c.r},${c.g},${c.b}); border: 1px solid var(--border); margin: 1px;"></div>`
                    ).join('');
                    previewHTML += `<br><button class="btn btn-secondary" style="padding: 4px 12px; margin-top: 5px;" onclick="viewPalette(${start + idx})">View Palette</button>`;
                }
                
                // Add graphics viewer button
                if (p.isGraphics || p.isCompressed) {
                    previewHTML = `<button class="btn btn-secondary" style="padding: 4px 12px;" onclick="viewGraphics(${start + idx})">üé® View Asset</button>`;
                }

                return `
                    <tr>
                        <td><code style="color: var(--accent);">${p.offset}</code></td>
                        <td><span class="category-badge cat-${p.type}">${p.type.toUpperCase()}</span></td>
                        <td>${p.desc}</td>
                        <td><div class="decoded-info"><span class="hex-decode">${p.decoded}</span></div></td>
                        <td>${previewHTML}</td>
                    </tr>
                `;
            }).join('');

            const totalPages = Math.ceil(filteredPatterns.length / patternsPerPage);
            document.getElementById('pageInfo').textContent = 
                `Page ${currentPage} of ${totalPages} (${start + 1}-${end} of ${filteredPatterns.length})`;
            document.getElementById('prevBtn').disabled = currentPage === 1;
            document.getElementById('nextBtn').disabled = currentPage === totalPages;
        }

        // Graphics viewer functions
        function viewPalette(index) {
            const pattern = filteredPatterns[index];
            if (!pattern.colors) return;

            const modal = document.getElementById('spriteModal');
            const content = document.getElementById('modalContent');
            
            let html = `<h3>Color Palette at ${pattern.offset}</h3>`;
            html += `<div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 10px; margin: 20px 0;">`;
            
            pattern.colors.forEach((c, i) => {
                html += `
                    <div style="text-align: center;">
                        <div style="width: 50px; height: 50px; background: rgb(${c.r},${c.g},${c.b}); border: 2px solid var(--border); margin: 0 auto;"></div>
                        <div style="font-size: 0.8em; margin-top: 5px;">RGB(${c.r},${c.g},${c.b})</div>
                        <div style="font-size: 0.7em; color: var(--text-secondary);">Index ${i}</div>
                    </div>
                `;
            });
            
            html += `</div>`;
            html += `<button class="btn" onclick="downloadPalette(${index})">üíæ Download Palette (.pal)</button>`;
            
            content.innerHTML = html;
            modal.style.display = 'block';
        }

        function viewGraphics(index) {
            const pattern = filteredPatterns[index];
            const offset = parseInt(pattern.offset.replace('0x', ''), 16);
            
            const modal = document.getElementById('spriteModal');
            const content = document.getElementById('modalContent');
            
            let html = `<h3>Graphics Asset at ${pattern.offset}</h3>`;
            
            if (pattern.isCompressed) {
                // Decompress LZ77
                try {
                    const decompressed = decompressLZ77(offset);
                    if (decompressed) {
                        const canvas = renderTiles(decompressed, 8, 4); // 8 tiles wide
                        html += `<p>Decompressed size: ${decompressed.length} bytes (${Math.floor(decompressed.length / 32)} tiles)</p>`;
                        html += `<div style="margin: 20px 0;">${canvas.outerHTML}</div>`;
                        html += `<button class="btn" onclick="downloadGraphics(${index}, 'decompressed')">üíæ Download Image</button>`;
                    } else {
                        html += `<p style="color: var(--error);">Failed to decompress data</p>`;
                    }
                } catch (e) {
                    html += `<p style="color: var(--error);">Error: ${e.message}</p>`;
                }
            } else {
                // Render uncompressed 4BPP
                const tileCount = 64; // Show 64 tiles
                const tileData = romData.slice(offset, offset + (tileCount * 32));
                const canvas = renderTiles(tileData, 8, 4);
                html += `<p>Showing ${tileCount} tiles (8x8 pixels, 4BPP)</p>`;
                html += `<div style="margin: 20px 0;">${canvas.outerHTML}</div>`;
                html += `<button class="btn" onclick="downloadGraphics(${index}, 'uncompressed')">üíæ Download Image</button>`;
            }
            
            content.innerHTML = html;
            modal.style.display = 'block';
        }

        function renderTiles(data, tilesWide, bpp) {
            const tileCount = Math.floor(data.length / 32);
            const tilesHigh = Math.ceil(tileCount / tilesWide);
            
            const canvas = document.createElement('canvas');
            canvas.width = tilesWide * 8;
            canvas.height = tilesHigh * 8;
            canvas.style.imageRendering = 'pixelated';
            canvas.style.width = (tilesWide * 8 * 4) + 'px';
            canvas.style.height = (tilesHigh * 8 * 4) + 'px';
            
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(canvas.width, canvas.height);
            
            // Default grayscale palette for 4BPP
            const palette = [];
            for (let i = 0; i < 16; i++) {
                const val = Math.floor((i / 15) * 255);
                palette.push({ r: val, g: val, b: val });
            }
            
            // Render each tile
            for (let t = 0; t < tileCount; t++) {
                const tileX = (t % tilesWide) * 8;
                const tileY = Math.floor(t / tilesWide) * 8;
                const tileOffset = t * 32;
                
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        const pixelOffset = tileOffset + (y * 4) + Math.floor(x / 2);
                        if (pixelOffset >= data.length) continue;
                        
                        const byte = data[pixelOffset];
                        const colorIndex = (x % 2 === 0) ? (byte & 0x0F) : (byte >> 4);
                        const color = palette[colorIndex];
                        
                        const imgX = tileX + x;
                        const imgY = tileY + y;
                        const imgOffset = (imgY * canvas.width + imgX) * 4;
                        
                        imgData.data[imgOffset] = color.r;
                        imgData.data[imgOffset + 1] = color.g;
                        imgData.data[imgOffset + 2] = color.b;
                        imgData.data[imgOffset + 3] = 255;
                    }
                }
            }
            
            ctx.putImageData(imgData, 0, 0);
            return canvas;
        }

        function decompressLZ77(offset) {
            if (romData[offset] !== 0x10) return null;
            
            const decompSize = readU24(offset + 1);
            const output = new Uint8Array(decompSize);
            let outPos = 0;
            let inPos = offset + 4;
            
            while (outPos < decompSize && inPos < romData.length) {
                const flags = romData[inPos++];
                
                for (let i = 0; i < 8 && outPos < decompSize; i++) {
                    if (flags & (0x80 >> i)) {
                        // Compressed
                        if (inPos + 1 >= romData.length) break;
                        const b1 = romData[inPos++];
                        const b2 = romData[inPos++];
                        const len = ((b1 >> 4) & 0x0F) + 3;
                        const disp = (((b1 & 0x0F) << 8) | b2) + 1;
                        
                        for (let j = 0; j < len && outPos < decompSize; j++) {
                            output[outPos] = output[outPos - disp];
                            outPos++;
                        }
                    } else {
                        // Uncompressed
                        if (inPos >= romData.length) break;
                        output[outPos++] = romData[inPos++];
                    }
                }
            }
            
            return output;
        }

        function downloadPalette(index) {
            const pattern = filteredPatterns[index];
            if (!pattern.colors) return;
            
            // Create .pal file format
            let palData = 'JASC-PAL\r\n0100\r\n256\r\n';
            pattern.colors.forEach(c => {
                palData += `${c.r} ${c.g} ${c.b}\r\n`;
            });
            
            downloadFile(palData, `palette_${pattern.offset}.pal`, 'text/plain');
            showAlert('success', '‚úÖ Palette downloaded');
        }

        function downloadGraphics(index, type) {
            const pattern = filteredPatterns[index];
            const offset = parseInt(pattern.offset.replace('0x', ''), 16);
            
            let canvas;
            if (type === 'decompressed') {
                const decompressed = decompressLZ77(offset);
                canvas = renderTiles(decompressed, 8, 4);
            } else {
                const tileData = romData.slice(offset, offset + (64 * 32));
                canvas = renderTiles(tileData, 8, 4);
            }
            
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `graphics_${pattern.offset}.png`;
                a.click();
                URL.revokeObjectURL(url);
                showAlert('success', '‚úÖ Image downloaded');
            });
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function closeModal() {
            document.getElementById('spriteModal').style.display = 'none';
        }

        // Helper functions
        function readU32(offset) {
            return romData[offset] | (romData[offset + 1] << 8) | 
                   (romData[offset + 2] << 16) | (romData[offset + 3] << 24);
        }

        function readU32Arr(arr, offset) {
            return arr[offset] | (arr[offset + 1] << 8) | 
                   (arr[offset + 2] << 16) | (arr[offset + 3] << 24);
        }

        function readU16(offset) {
            return romData[offset] | (romData[offset + 1] << 8);
        }

        function readU24(offset) {
            return romData[offset] | (romData[offset + 1] << 8) | (romData[offset + 2] << 16);
        }

        function isASCII(byte) {
            return byte >= 0x20 && byte <= 0x7E;
        }

        function updateDisplay() {
            filteredPatterns = allPatterns;
            currentPage = 1;
            renderPage();
        }

        document.getElementById('prevBtn').onclick = () => {
            if (currentPage > 1) { currentPage--; renderPage(); }
        };

        document.getElementById('nextBtn').onclick = () => {
            const totalPages = Math.ceil(filteredPatterns.length / patternsPerPage);
            if (currentPage < totalPages) { currentPage++; renderPage(); }
        };

        document.getElementById('searchBox').oninput = (e) => {
            const term = e.target.value.toLowerCase();
            filteredPatterns = term ? allPatterns.filter(p => 
                p.offset.toLowerCase().includes(term) || 
                p.type.includes(term) || 
                p.desc.toLowerCase().includes(term) ||
                p.decoded.toLowerCase().includes(term) ||
                p.preview.toLowerCase().includes(term) ||
                (p.fullText && p.fullText.toLowerCase().includes(term))
            ) : allPatterns;
            currentPage = 1;
            renderPage();
        };

        document.getElementById('loadMoreBtn').onclick = async () => {
            showScanStatus('Scanning more patterns...');
            await scanPatterns(loadMoreLimit);
            hideScanStatus();
            updateDisplay();
            showAlert('success', `‚úÖ Now ${allPatterns.length} patterns total`);
        };

        function updateLoadMore() {
            document.getElementById('loadMoreSection').classList.remove('hidden');
            document.getElementById('currentCount').textContent = allPatterns.length;
            document.getElementById('scanPercent').textContent = 
                Math.round((scanPosition / romData.length) * 100);
        }

        document.getElementById('exportBtn').onclick = () => {
            const data = {
                rom: romFileName,
                date: new Date().toISOString(),
                totalPatterns: allPatterns.length,
                patterns: allPatterns.map(p => ({
                    offset: p.offset,
                    type: p.type,
                    description: p.desc,
                    decoded: p.decoded,
                    preview: p.preview
                }))
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = romFileName.replace('.gba', '') + '_deep_analysis.json';
            a.click();
            URL.revokeObjectURL(url);
            showAlert('success', '‚úÖ Exported analysis data');
        };

        function showScanStatus(msg) {
            document.getElementById('scanMessage').textContent = msg;
            document.getElementById('scanStatus').classList.remove('hidden');
        }

        function hideScanStatus() {
            document.getElementById('scanStatus').classList.add('hidden');
        }

        function showAlert(type, msg) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = msg;
            document.getElementById('alerts').appendChild(alertDiv);
            setTimeout(() => alertDiv.remove(), 4000);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Close modal when clicking outside
        window.onclick = (e) => {
            const modal = document.getElementById('spriteModal');
            if (e.target === modal) closeModal();
        };
    </script>
</body>
</html>
